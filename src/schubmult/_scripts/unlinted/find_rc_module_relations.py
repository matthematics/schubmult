#!/usr/bin/env python3
"""
Find relations for the module of all RC graphs of length n as a right module 
over the ring of n-Grassmannian RC graphs.

The Grassmannian RC graphs form a subring (using the % operation), and all RC graphs
of length n form a module over this ring. The module is finitely generated by RC graphs
corresponding to S_n (with strictly fewer than n rows occupied).

This script:
1. Generates all Grassmannian RC graphs for length n (these form the ring)
2. Generates all RC graphs for S_n with < n rows (these are the module generators)
3. Finds relations among products of generators with Grassmannian elements
4. Outputs a presentation (generators + relations)
"""

from itertools import combinations, product
from collections import defaultdict
from schubmult import RCGraph, RCGraphRing, Permutation, uncode
from schubmult.symbolic import sympify, S, simplify
from sympy import Matrix, gcd, lcm, Rational
from fractions import Fraction


def generate_grassmannian_permutations(n):
    """
    Generate Grassmannian permutations for the ring.
    These are:
    - The identity permutation (no descents)
    - Permutations with exactly one descent at position n-1 (0-indexed)
    
    For the % operation to work with non-dominant permutations, 
    we need Grassmannian permutations with descent at position n-1.
    """
    grass_perms = []
    
    # Always include identity
    grass_perms.append(Permutation([]))
    
    # Generate permutations with exactly one descent at position n-1 (0-indexed)
    # This requires permutations of length >= n
    for length in range(n, n + 3):  # Check a couple lengths beyond n
        for perm in Permutation.all_permutations(length):
            descents = perm.descents()
            # Exactly one descent at position n-1 (0-indexed)
            if len(descents) == 1 and (n - 1) in descents:
                grass_perms.append(perm)
    
    return grass_perms


def generate_sn_permutations(n):
    """
    Generate all permutations in S_n (length at most n).
    These correspond to RC graphs with strictly fewer than n rows occupied.
    """
    perms = []
    for k in range(n):
        perms.extend(Permutation.all_permutations(k))
    return perms


def is_elementary_symmetric_grassmannian(perm):
    """
    Check if a Grassmannian permutation corresponds to elementary symmetric function.
    For Grassmannian with one descent at n-1, elementary symmetric e_k corresponds
    to partition (1,1,...,1) with k parts (vertical).
    This means: [2,3,...,k+1,1] or similar patterns.
    """
    descents = perm.descents()
    if len(descents) != 1:
        return False
    
    # For elementary symmetric, the partition is vertical (1,1,...,1)
    # This happens when the permutation has the pattern where
    # we move exactly one element (the smallest) to the end
    # Pattern: [2,3,4,...,k+1,1] for e_k
    
    # Check if it's of the form: consecutive integers starting from 2, then 1
    perm_list = list(perm)
    if not perm_list:
        return False
    
    # Elementary: starts with 2,3,4,... and ends with 1
    if perm_list[-1] == 1:
        # Check if the rest is consecutive starting from 2
        for i, val in enumerate(perm_list[:-1], start=2):
            if val != i:
                return False
        return True
    
    return False


def is_complete_symmetric_grassmannian(perm):
    """
    Check if a Grassmannian permutation corresponds to complete symmetric function.
    For Grassmannian with one descent at n-1, complete symmetric h_k corresponds
    to partition (k) (horizontal).
    This means: [1,2,...,n-1,n+k,n] or [1,2,...,i-1,i+1,...,n,i] patterns.
    """
    descents = perm.descents()
    if len(descents) != 1:
        return False
    
    # For complete symmetric, the partition is horizontal (k)
    # Pattern: [1,2,...,i-1,i+1,...,n,i] - one element moved to the end
    # or [1,2,...,n-1,n+1,n] for h_1
    
    perm_list = list(perm)
    if not perm_list:
        return False
    
    # Check if exactly one element is out of place (moved to the end)
    # and everything else is in order
    last_val = perm_list[-1]
    
    # Check if elements before the last are 1,2,...,last_val-1,last_val+1,...,n
    expected = []
    for i in range(1, len(perm_list) + 1):
        if i != last_val:
            expected.append(i)
    
    if perm_list[:-1] == expected:
        return True
    
    return False


def filter_symmetric_grassmannian(grass_rcs, symmetric_type='both'):
    """
    Filter Grassmannian RC graphs to only those corresponding to
    elementary or complete symmetric functions.
    
    Args:
        grass_rcs: List of Grassmannian RC graphs
        symmetric_type: 'elementary', 'complete', or 'both'
    
    Returns:
        Filtered list of RC graphs
    """
    filtered = []
    for rc in grass_rcs:
        perm = rc.perm
        
        if symmetric_type in ['elementary', 'both']:
            if is_elementary_symmetric_grassmannian(perm):
                filtered.append(rc)
                continue
        
        if symmetric_type in ['complete', 'both']:
            if is_complete_symmetric_grassmannian(perm):
                filtered.append(rc)
                continue
    
    return filtered


def generate_k_grassmannian_permutations(k):
    """
    Generate k-Grassmannian permutations: identity or exactly one descent at position k-1.
    These are length k or k+1.
    """
    grass_perms = []
    
    # Always include identity
    grass_perms.append(Permutation([]))
    
    # Generate permutations with exactly one descent at position k-1 (0-indexed)
    # This requires permutations of length >= k
    for length in range(k, k + 2):  # Check lengths k and k+1
        for perm in Permutation.all_permutations(length):
            descents = perm.descents()
            # Exactly one descent at position k-1 (0-indexed)
            if len(descents) == 1 and (k - 1) in descents:
                grass_perms.append(perm)
    
    return grass_perms


def get_k_grassmannian_rc_graphs(k, n):
    """
    Get all k-Grassmannian RC graphs with exactly n rows.
    """
    grass_perms = generate_k_grassmannian_permutations(k)
    grass_rcs = []
    
    for perm in grass_perms:
        # Only include if the permutation fits in n rows
        if len(perm.trimcode) <= n:
            try:
                for rc in RCGraph.all_rc_graphs(perm, n):
                    grass_rcs.append(rc)
            except ValueError:
                # Skip permutations that don't fit
                continue
    
    return grass_rcs


def get_grassmannian_rc_graphs(n):
    """
    Get all Grassmannian RC graphs with exactly n rows.
    """
    grass_perms = generate_grassmannian_permutations(n)
    grass_rcs = []
    
    for perm in grass_perms:
        # Only include if the permutation fits in n rows
        if len(perm.trimcode) <= n:
            try:
                for rc in RCGraph.all_rc_graphs(perm, n):
                    grass_rcs.append(rc)
            except ValueError:
                # Skip permutations that don't fit
                continue
    
    return grass_rcs


def get_module_generators(n):
    """
    Get module generators: RC graphs for S_n with < n rows occupied.
    All RC graphs have exactly n rows (the nth row is empty for these permutations).
    """
    sn_perms = generate_sn_permutations(n)
    generator_rcs = []
    
    for perm in sn_perms:
        # All RC graphs have n rows
        for rc in RCGraph.all_rc_graphs(perm, n):
            generator_rcs.append(rc)
    
    return generator_rcs


def find_linear_dependencies(rc_ring, elements):
    """
    Find integer linear dependencies among a list of RC graph ring elements.
    Returns a list of relations as integer coefficient vectors.
    """
    if not elements:
        return []
    
    # Collect all basis elements that appear
    basis_elements = set()
    for elem in elements:
        basis_elements.update(elem.keys())
    basis_elements = sorted(basis_elements, key=lambda x: (len(x), tuple(x)))
    
    # Build matrix: each column is an element, each row is a basis coefficient
    # Use integer coefficients only
    matrix_data = []
    for basis_rc in basis_elements:
        row = []
        for elem in elements:
            coeff = elem.get(basis_rc, 0)
            # Ensure integer coefficient
            if hasattr(coeff, 'is_Integer') and coeff.is_Integer:
                row.append(int(coeff))
            elif isinstance(coeff, (int, Fraction)):
                row.append(int(coeff))
            else:
                try:
                    row.append(int(coeff))
                except:
                    row.append(0)
        matrix_data.append(row)
    
    if not matrix_data or not matrix_data[0]:
        return []
    
    # Use sympy Matrix for exact integer arithmetic
    mat = Matrix(matrix_data)
    
    # Find null space using sympy (exact rational arithmetic)
    try:
        null_space = mat.nullspace()
        
        relations = []
        for null_vec in null_space:
            # Convert to integer coefficients by clearing denominators
            coeffs = list(null_vec)
            
            # Find LCM of all denominators to clear them
            denoms = []
            for c in coeffs:
                if hasattr(c, 'as_numer_denom'):
                    _, denom = c.as_numer_denom()
                    denoms.append(denom)
                else:
                    denoms.append(1)
            
            if denoms:
                lcm_val = denoms[0]
                for d in denoms[1:]:
                    lcm_val = lcm(lcm_val, d)
                
                # Multiply through by LCM to get integers
                int_coeffs = []
                for c in coeffs:
                    int_coeffs.append(int(simplify(c * lcm_val)))
                
                # Find GCD to reduce
                gcd_val = int_coeffs[0] if int_coeffs else 1
                for ic in int_coeffs[1:]:
                    if ic != 0:
                        gcd_val = gcd(gcd_val, ic)
                
                if gcd_val != 0 and gcd_val != 1:
                    int_coeffs = [ic // gcd_val for ic in int_coeffs]
                
                if any(ic != 0 for ic in int_coeffs):
                    relations.append(int_coeffs)
        
        return relations
    except Exception as e:
        print(f"Warning: Nullspace computation failed: {e}")
        return []


def find_module_relations(n, max_products=None, verbose=True, degree_1_only=False, k_grassmannian_generators=None, symmetric_type=None):
    """
    Find relations in the module of RC graphs over the Grassmannian ring.
    All RC graphs have exactly n rows.
    
    Args:
        n: The parameter n (all RC graphs have n rows, module generated by S_n elements)
        max_products: Maximum number of products to consider (None = all)
        verbose: Print progress information
        degree_1_only: If True, only use degree 1 Grassmannian elements (length n+1)
        k_grassmannian_generators: If provided, use only k-Grassmannian generators (list of k values)
        symmetric_type: If provided, filter to 'elementary', 'complete', or 'both' symmetric functions
    
    Returns:
        Dictionary with:
        - 'generators': List of module generators
        - 'grassmannian_elements': List of Grassmannian RC graphs (ring elements)
        - 'relations': List of relations
        - 'products': Dictionary mapping (gen, grass) pairs to products
    """
    if verbose:
        degree_str = " (degree 1 only)" if degree_1_only else ""
        k_str = f" (k-Grassmannian generators: {k_grassmannian_generators})" if k_grassmannian_generators else ""
        sym_str = f" (symmetric type: {symmetric_type})" if symmetric_type else ""
        print(f"Finding relations for n={n} (all RC graphs have {n} rows){degree_str}{k_str}{sym_str}")
    
    # Initialize ring
    rc_ring = RCGraphRing()
    
    # Get Grassmannian elements (ring)
    if verbose:
        print("Generating Grassmannian RC graphs (ring elements)...")
    grass_rcs = get_grassmannian_rc_graphs(n)
    
    # Filter to symmetric type if requested
    if symmetric_type:
        grass_rcs = filter_symmetric_grassmannian(grass_rcs, symmetric_type)
        if verbose:
            print(f"  Filtered to {symmetric_type} symmetric: {len(grass_rcs)} Grassmannian RC graphs")
    # Filter to degree 1 only if requested
    elif degree_1_only:
        grass_rcs = [rc for rc in grass_rcs if len(rc.perm) == n + 1]
        if verbose:
            print(f"  Filtered to degree 1: {len(grass_rcs)} Grassmannian RC graphs (length {n+1})")
    else:
        if verbose:
            print(f"  Found {len(grass_rcs)} Grassmannian RC graphs")
    
    # Get module generators...")
    
    if k_grassmannian_generators:
        # Use k-Grassmannian generators
        gen_rcs = []
        for k in k_grassmannian_generators:
            k_grass_rcs = get_k_grassmannian_rc_graphs(k, n)
            gen_rcs.extend(k_grass_rcs)
            if verbose:
                print(f"  Found {len(k_grass_rcs)} {k}-Grassmannian RC graphs")
        if verbose:
            print(f"  Total: {len(gen_rcs)} k-Grassmannian generators")
    else:
        # Use all S_n RC graphs
        gen_rcs = get_module_generators(n)
        if verbose:
            print(f"  Found {len(gen_rcs)} module generators (S_n RC graphs)")
    
    # Compute products: generator % grassmannian_element
    if verbose:
        print("Computing products...")
    
    # Store products and track which (gen, grass) pairs produce each result RC graph
    products = {}  # (gen_rc, grass_rc) -> product RCGraphRingElement
    result_to_pairs = defaultdict(list)  # result RC graph -> list of (gen_rc, grass_rc) pairs
    
    count = 0
    for gen_rc in gen_rcs:
        for grass_rc in grass_rcs:
            if max_products and count >= max_products:
                break
            
            try:
                # Use % operator for the module action
                gen_elem = rc_ring(gen_rc)
                grass_elem = rc_ring(grass_rc)
                product = gen_elem % grass_elem
                
                # Each product should be a single RC graph (the user says so)
                if len(product) == 1:
                    result_rc = list(product.keys())[0]
                    result_coeff = product[result_rc]
                    
                    products[(gen_rc, grass_rc)] = product
                    # Store the pair that produced this result
                    result_to_pairs[result_rc].append((gen_rc, grass_rc, result_coeff))
                elif len(product) == 0:
                    # Empty product, skip
                    pass
                else:
                    if verbose:
                        print(f"  Warning: Product {gen_rc} % {grass_rc} gave multiple terms: {product}")
                
                count += 1
                if verbose and count % 100 == 0:
                    print(f"  Computed {count} products...")
            except Exception as e:
                if verbose:
                    print(f"  Warning: Failed to compute {gen_rc} % {grass_rc}: {e}")
                continue
        
        if max_products and count >= max_products:
            break
    
    if verbose:
        print(f"  Total products computed: {count}")
    
    # Find relations: when multiple (gen, grass) pairs produce the same result RC graph
    if verbose:
        print("Finding relations (products that yield the same result)...")
    
    formatted_relations = []
    relation_results = []  # Store the result RC graph for each relation
    
    for result_rc, pairs in result_to_pairs.items():
        if len(pairs) >= 2:
            # Group by (gen_perm, grass_perm) to identify distinct products
            perm_pairs_map = {}
            for gen_rc, grass_rc, coeff in pairs:
                key = (gen_rc.perm, grass_rc.perm)
                if key not in perm_pairs_map:
                    perm_pairs_map[key] = []
                perm_pairs_map[key].append((gen_rc, grass_rc, coeff))
            
            # Get one representative from each (gen_perm, grass_perm) group
            unique_products = []
            for key, rc_list in perm_pairs_map.items():
                # Take the first RC graph pair for this permutation pair
                unique_products.append(rc_list[0])
            
            # Now check if we have at least 2 distinct permutation products
            if len(unique_products) >= 2:
                # Look for pairs where at most one is identity
                for i in range(len(unique_products)):
                    for j in range(i + 1, len(unique_products)):
                        gen1_rc, grass1_rc, coeff1 = unique_products[i]
                        gen2_rc, grass2_rc, coeff2 = unique_products[j]
                        
                        gen1_perm = gen1_rc.perm
                        gen2_perm = gen2_rc.perm
                        
                        # Skip if both are identity
                        if gen1_perm.inv == 0 and gen2_perm.inv == 0:
                            continue
                        
                        # We have a non-trivial relation!
                        relation = [
                            (coeff1, gen1_rc, grass1_rc),
                            (-coeff2, gen2_rc, grass2_rc)
                        ]
                        
                        formatted_relations.append(relation)
                        relation_results.append(result_rc)
    
    if verbose:
        print(f"  Found {len(formatted_relations)} non-trivial relations")
    
    return {
        'generators': gen_rcs,
        'grassmannian_elements': grass_rcs,
        'relations': formatted_relations,
        'relation_results': relation_results,
        'products': products,
        'result_to_pairs': dict(result_to_pairs),
    }


def print_relation(relation, result_rc=None, index=None):
    """Pretty print a single relation."""
    if index is not None:
        print(f"\nRelation {index}:")
    else:
        print("\nRelation:")
    
    # Show the result RC graph that all these products yield
    if result_rc is not None:
        print(f"  All products below yield: {result_rc}")
    
    terms = []
    for coeff, gen_rc, grass_rc in relation:
        if coeff == 0:
            continue
            
        sign = "+" if coeff >= 0 else "-"
        abs_coeff = abs(coeff)
        
        if abs_coeff == 1:
            coeff_str = ""
        else:
            coeff_str = f"{abs_coeff}*"
        
        # Format permutations nicely - show full array notation
        gen_str = str(list(gen_rc.perm)) if len(gen_rc.perm) > 0 else "id"
        grass_str = str(list(grass_rc.perm)) if len(grass_rc.perm) > 0 else "id"
        
        # Note: This is a right module action, so gen % grass means gen acts on the right by grass
        term = f"{sign} {coeff_str}(RC{gen_str} % Grass{grass_str})"
        terms.append(term)
    
    if not terms:
        print("  0 = 0 (trivial)")
        return
    
    # Join terms, handling the first term's sign
    relation_str = " ".join(terms)
    if relation_str.startswith("+ "):
        relation_str = relation_str[2:]
    
    print(f"  {relation_str} = 0")


def print_results(results, max_relations=10):
    """Print a summary of the results."""
    print("\n" + "="*80)
    print("MODULE PRESENTATION RESULTS")
    print("="*80)
    
    print(f"\nNumber of module generators: {len(results['generators'])}")
    print(f"Number of Grassmannian elements (ring): {len(results['grassmannian_elements'])}")
    print(f"Number of products computed: {len(results['products'])}")
    print(f"Number of distinct result RC graphs: {len(results['result_to_pairs'])}")
    print(f"Number of relations found: {len(results['relations'])}")
    
    if results['relations']:
        print(f"\nShowing first {min(max_relations, len(results['relations']))} relations:")
        for i, relation in enumerate(results['relations'][:max_relations]):
            result_rc = results['relation_results'][i] if i < len(results['relation_results']) else None
            print_relation(relation, result_rc=result_rc, index=i+1)
        
        if len(results['relations']) > max_relations:
            print(f"\n... and {len(results['relations']) - max_relations} more relations")
    else:
        print("\nNo non-trivial relations found!")


def export_results(results, filename):
    """Export results to a file."""
    with open(filename, 'w') as f:
        f.write("Module Presentation for RC Graphs\n")
        f.write("="*80 + "\n\n")
        
        f.write(f"Number of Generators: {len(results['generators'])}\n")
        f.write(f"Number of Grassmannian Elements: {len(results['grassmannian_elements'])}\n")
        f.write(f"Number of Relations: {len(results['relations'])}\n\n")
        
        f.write("="*80 + "\n")
        f.write(f"RELATIONS ({len(results['relations'])})\n")
        f.write("="*80 + "\n\n")
        
        for i, relation in enumerate(results['relations']):
            f.write(f"\n{'='*80}\n")
            f.write(f"Relation {i+1}:\n")
            f.write(f"{'='*80}\n\n")
            
            # Show the result RC graph if available
            if 'relation_results' in results and i < len(results['relation_results']):
                result_rc = results['relation_results'][i]
                f.write("All products yield:\n")
                f.write(str(result_rc) + "\n")
                f.write(f"  Permutation: {list(result_rc.perm)}\n\n")
            
            # Show each term with its RC graphs
            for term_idx, (coeff, gen_rc, grass_rc) in enumerate(relation):
                sign = "+" if coeff > 0 else "-"
                abs_coeff = abs(int(coeff))
                coeff_str = "" if abs_coeff == 1 else f"{abs_coeff}*"
                
                if term_idx == 0:
                    f.write(f"  {coeff_str}(\n")
                else:
                    f.write(f"\n  {sign} {coeff_str}(\n")
                
                f.write(f"    Generator RC graph (perm {list(gen_rc.perm)}):\n")
                for line in str(gen_rc).split('\n'):
                    f.write(f"      {line}\n")
                
                f.write(f"\n    %\n\n")
                
                f.write(f"    Grassmannian RC graph (perm {list(grass_rc.perm)}):\n")
                for line in str(grass_rc).split('\n'):
                    f.write(f"      {line}\n")
                
                f.write("  )")
            
            f.write("\n\n  = 0\n\n")


if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Find relations for RC graph module over Grassmannian ring. "
                    "All RC graphs have exactly n rows."
    )
    parser.add_argument("n", type=int, help="Parameter n (all RC graphs have n rows, module generated by S_n)")
    parser.add_argument("--max-products", type=int, default=None,
                       help="Maximum number of products to compute")
    parser.add_argument("--output", type=str, default=None,
                       help="Output file for results")
    parser.add_argument("--quiet", action="store_true",
                       help="Suppress progress output")
    parser.add_argument("--max-relations", type=int, default=10,
                       help="Maximum number of relations to display (default: 10, use 0 for all)")
    parser.add_argument("--degree-1-only", action="store_true",
                       help="Use only degree 1 Grassmannian elements (length n+1)")
    parser.add_argument("--k-grassmannian", type=str, default=None,
                       help="Use only k-Grassmannian generators (comma-separated list, e.g., '1,2')")
    parser.add_argument("--symmetric", type=str, default=None, choices=['elementary', 'complete', 'both'],
                       help="Filter Grassmannian elements to elementary/complete symmetric functions")
    
    args = parser.parse_args()
    
    # Parse k-Grassmannian argument
    k_grass_list = None
    if args.k_grassmannian:
        k_grass_list = [int(k.strip()) for k in args.k_grassmannian.split(',')]
    
    # Find relations
    results = find_module_relations(
        n=args.n,
        max_products=args.max_products,
        verbose=not args.quiet,
        degree_1_only=args.degree_1_only,
        k_grassmannian_generators=k_grass_list,
        symmetric_type=args.symmetric
    )
    
    # Print results
    print_results(results, max_relations=args.max_relations)
    
    # Export if requested
    if args.output:
        export_results(results, args.output)
        print(f"\nResults exported to {args.output}")
