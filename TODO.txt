TODO:

inject variables
parser sage tests
more script tests (parabolic?)
PARABOLIC

# HARD POSITIVE ERRORS


DIV DIFF MAYBE NILHECKERING

# infinite parabolic rings

!!PERM tests!!
SCHUB tests

Switch off best effort positive
# Quantum correctness tests
Coerce tensor rings
document

DOCS

# perm actions
# PERMUTATION CALL check

# free_symbols and sub
# sympy guardrails for GeneratingSet check


Convert poly permute monomial
Fast basis change
# Fix subs 

# Change vars breaks if not positive

Test if Poly technique is faster
Results: higher degree and/or fewer terms, poly faster

# Use symengine for everything possible

more tests

subs faster, do better with dense product

# Parabolic classical if that's what we want

# code display!!! !!!

DIFFERENT Q VARS

# refactor scripts to print as code

parallelism if useful

What do we want the API to be?

# Permutation static functions

All polynomial funcs

# Have scripts only use basic functions

# Peterson-Woodward in basic libraries

rewrite rules to re-express

# parabolic script tests

# Single var quantum parabolic

Drawing

# Best effort positive for same var (speed?)

# Script display order = 'old'

FOCUS ON SEM basis!!!!!!!!!

Single SEM, avoids 312 and 1432
What about single EM at all, not necessarily SEM?
Div diffs on the SEMS that don't expand them
1423, 1432, 4132, 3142

123
312
132

132
321

321
132
312

312
213
132
231


Avoids 1432, and if it has a 312 then it has repeats

multiples

!!4132 = e_1_1 * 3142!!


you don't have to touch the 2 at the end

A D A    A D D  D A D   D A D
string generation is expensive. Cache?

SEM tests

Pytest virtual env

One path

v is a length-additive product of theta(~v) elem cycles

coprod pattern

Can pull out boink-thetainverse
reduce coeff

ladder moves

UNIVERSAL SCHUBS

For positivity, when can we factor out elem syms?
That could make it much faster and positivity easier