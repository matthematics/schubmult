TODO:

inject variables
parser sage tests
more script tests (parabolic?)
PARABOLIC

# HARD POSITIVE ERRORS


DIV DIFF MAYBE NILHECKERING

# infinite parabolic rings

!!PERM tests!!
SCHUB tests

Switch off best effort positive
# Quantum correctness tests
Coerce tensor rings
document

DOCS

# perm actions
# PERMUTATION CALL check

# free_symbols and sub
# sympy guardrails for GeneratingSet check


Convert poly permute monomial
Fast basis change
# Fix subs 

# Change vars breaks if not positive

Test if Poly technique is faster
Results: higher degree and/or fewer terms, poly faster

# Use symengine for everything possible

more tests

subs faster, do better with dense product

# Parabolic classical if that's what we want

# code display!!! !!!

DIFFERENT Q VARS

# refactor scripts to print as code

parallelism if useful

Permutation class functions

All polynomial funcs

# Have scripts only use basic functions

# Peterson-Woodward in basic libraries

rewrite rules to re-express

# parabolic script tests

# Single var quantum parabolic

Drawing

# Best effort positive for same var (speed?)

# Script display order = 'old'

FOCUS ON SEM basis!!!!!!!!!

Single SEM, avoids 312 and 1432
What about single EM at all, not necessarily SEM?
Div diffs on the SEMS that don't expand them
1423, 1432, 4132, 3142

123
312
132

132
321

321
132
312

312
213
132
231


Avoids 1432, and if it has a 312 then it has repeats

multiples

!!4132 = e_1_1 * 3142!!


string generation is expensive. Cache?

SEM tests

Pytest virtual env

UNIVERSAL SCHUBS

For positivity, when can we factor out elem syms?
That could make it much faster and positivity easier

Very useful to detect if reducible

If it factorizes? 

# Pull out generator

Pull out elem sym
nil hecke

more formalism around elem sym
coproduct of inverse
elem sym coproduct

when do Schub products combine

Elem sym vars

principal specialization

Avoiding: Can never increase by 2 from any point
If there is a code ascent, the line has to clear the peaks

Flattened perm, chop off the beginning
Each code non-move increases the rank element by 1
So 3142 and 4132 are non-clearing patterns

1. Code cannot increase by more than one total from any point left to right
2. Increases must clear previous decreases

# Patterns kind of correspond to coproducts

SEM fact looks good

Factorizes if and only if vpath, and is shub

3 9 36 207 1550

Very little benefit to allowing mixed generating sets
Unevaluated sums instead
Coefficient variables as part of the basis
Then can do coeff coproducts to factorize

Put back schubadd? No

But schub element coercion

coeff var coproduct can actually be expressed fully as products of normal double Schubs with coeffs

quantum subs
change vars
coercion order decorator

speed up single var coproduct

Make use of variable separation as a last resort to avoid linear optimization