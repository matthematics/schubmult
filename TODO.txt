TODO:

inject variables
parser sage tests
more script tests (parabolic?)
PARABOLIC

# HARD POSITIVE ERRORS


DIV DIFF MAYBE NILHECKERING

# infinite parabolic rings

!!PERM tests!!
SCHUB tests

Switch off best effort positive
# Quantum correctness tests
Coerce tensor rings
document

DOCS

# perm actions
# PERMUTATION CALL check

# free_symbols and sub
# sympy guardrails for GeneratingSet check


Convert poly permute monomial
Fast basis change
# Fix subs 

# Change vars breaks if not positive

Test if Poly technique is faster
Results: higher degree and/or fewer terms, poly faster

# Use symengine for everything possible

more tests

subs faster, do better with dense product

# Parabolic classical if that's what we want

# code display!!! !!!

DIFFERENT Q VARS

# refactor scripts to print as code

parallelism if useful

Permutation class functions

All polynomial funcs

# Have scripts only use basic functions

# Peterson-Woodward in basic libraries

rewrite rules to re-express

# parabolic script tests

# Single var quantum parabolic

Drawing

# Best effort positive for same var (speed?)

# Script display order = 'old'

FOCUS ON SEM basis!!!!!!!!!

Single SEM, avoids 312 and 1432
What about single EM at all, not necessarily SEM?
Div diffs on the SEMS that don't expand them
1423, 1432, 4132, 3142

123
312
132

132
321

321
132
312

312
213
132
231


Avoids 1432, and if it has a 312 then it has repeats

multiples

!!4132 = e_1_1 * 3142!!


string generation is expensive. Cache?

SEM tests

Pytest virtual env

UNIVERSAL SCHUBS

For positivity, when can we factor out elem syms?
That could make it much faster and positivity easier

Very useful to detect if reducible

If it factorizes? 

# Pull out generator

Pull out elem sym
nil hecke

more formalism around elem sym
coproduct of inverse
elem sym coproduct

when do Schub products combine

Elem sym vars

principal specialization

Avoiding: Can never increase by 2 from any point
If there is a code ascent, the line has to clear the peaks

Flattened perm, chop off the beginning
Each code non-move increases the rank element by 1
So 3142 and 4132 are non-clearing patterns

1. Code cannot increase by more than one total from any point left to right
2. Increases must clear previous decreases

# Patterns kind of correspond to coproducts

SEM fact looks good

Factorizes if and only if vpath, and is shub

3 9 36 207 1550

coeff var coproduct can actually be expressed fully as products of normal double Schubs with coeffs

speed up single var coproduct

Make use of variable separation as a last resort to avoid linear optimization

More tests

Each in the z_1 variables is independent


as_independent(*deps, **hint) â†’ tuple[Expr, Expr][source]
A mostly naive separation of a Mul or Add into arguments that are not are dependent on deps. To obtain as complete a separation of variables as possible, use a separation method first, e.g.:

separatevars() to change Mul, Add and Pow (including exp) into Mul

.expand(mul=True) to change Add or Mul into Add

.expand(log=True) to change log expr into an Add

Test separatevars before mult_poly

Element __call__ to substitute vals

pull_out_gen and eval tests
pull_out_gen for quantum

mul elem_sym

complete * elem - complete less vars , set z3 = y[k[0]] (fully positive)


A2 = A.ring.from_dict({k: v.subs(z[3],y[k[0]]) for k,v in A.items()})
3 1 4 2 = (DSx(uncode([2]),"z")*DSx(uncode([0,0,1]),"z") - DSx(uncode([3]),"z")).subs(z[3], y[k[0]])
4132, mul by x[1] - a[1], subs a[1], z[3]


DSx(uncode([1,1]))*DSx(uncode([0,0,1])) subs y[2] x[3]

DSx(uncode([0,2,1])) subs y[2] x[3]

quantum elem syms

coproduct vpathdicts

in complete sym basis
newton's formula

complete tests

single elem sym

express as elem sym to ease positivity testing 

faster way to posify with elem syms

different monomials are disjoint

cached elem sym eval

Allow zero coeff_vars/genvars

Difference algebra
Difference ideal groebner
groeber basis on (y1 - z1) ideal

Infinite gensets

We can get speed improvements by splitting into definitely linearly independent sets


Simplify elem sym (copy sympy)

apply rule to get into unique pieces

Positive iff has no minus signs?